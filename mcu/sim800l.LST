C51 COMPILER V9.01   SIM800L                                                               04/03/2019 12:37:18 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE SIM800L
OBJECT MODULE PLACED IN sim800l.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE sim800l.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg51.h>  
   2          #include <string.h>
   3          
   4          #define LENGTH 400              // 收到一条最大短信大概350字节
   5          
   6          unsigned char code TC_CONNECT[] = "AT";                                 // 发送内容连接
   7          unsigned char code TC_BAUD[] = "AT+IPR=19200";                  // 波特率
   8          unsigned char code TC_RUNMODE[] = "AT+CNMI=2,2,0,0,0";  // 发送内容模式
   9          
  10          unsigned char code TC_TCP_CHECKSIM[] = "AT+CPIN?";              // 1.检查SIM状态
  11          unsigned char code TC_TCP_CHECKNET[] = "AT+CSQ";                        // 2.检查网络信号强度
  12          unsigned char code TC_TCP_CHECKREG[] = "AT+CREG?";              // 3.检查网络注册状态
  13          unsigned char code TC_TCP_CHECKGPRS[] = "AT+CGATT?";            // 4.检查GPRS附着状态
  14          unsigned char code TC_TCP_SETAPN[] = "AT+CSTT=\"CMNET\"";// 5.设置APN
  15          unsigned char code TC_TCP_GETLINK[] = "AT+CIICR";               // 6.建立无线链路
  16          unsigned char code TC_TCP_GETIP[] = "AT+CIFSR";                 // 获得本地IP地址
  17          unsigned char code TC_TCP_TOSERVER[] = "AT+CIPSTART=\"TCP\",\"193.112.94.54\",\"9001\"";
  18          unsigned char code TC_TCP_SENDTEXT[] = "AT+CIPSEND";            // 发送具体数据
  19          unsigned char code TC_TCP_CLOSE[] = "AT+CIPCLOSE";              // 主动关闭链接
  20          unsigned char code TC_TCP_SHUT[] = "AT+CIPSHUT";                        // 关闭GPRS通信
  21          
  22          
  23          unsigned char xdata r_datas[LENGTH] = {0};                                              // 缓存MCU传入的数据
  24          unsigned char xdata t_datas[LENGTH] = {0};                                              // 传到TCP服务器的数据
  25          unsigned int data MAX=0;
  26          unsigned int data index=0;                                                              // 缓存数组索引
  27          
  28          //--声明全局函数--//
  29          void UsartConfiguration();                              // 串口参数配
  30          void Delay10ms(unsigned int c);                 // 误差 0us             # 感觉要*20 就是1000ms等于20s
  31          void Delay1ms(unsigned int i);
  32          void send_byte(unsigned char ch);               // 发送一个字节 
  33          void send_string(unsigned char *p);             // 发送字符串
  34          void print_r_datas();                                           // 调试用，输出r_datas数据
  35          void print_t_datas();                                           // 调试用，输出t_datas数据
  36          void clean_r_datas();                                           // data1数组清零
  37          
  38          
  39          void start();
  40          void sim800l_connect();                                 // 自适应波特率连接SIM800L模块
  41          void sim800l_set_baud();
  42          void sim800l_set_runmode();                             // 设置模块接收到新短信直接转发至MCU
  43          void sim800l_wait_sms();                                // 轮询短信
  44          
  45          void tcp();
  46          void tcp_1_checksim();
  47          void tcp_2_checknet();
  48          void tcp_3_checkreg();
  49          void tcp_4_checkgprs();
  50          void tcp_5_setapn();
  51          void tcp_6_getlink();
  52          void tcp_7_getip();
  53          void tcp_8_toserver();
  54          void tcp_9_sendtext();
  55          void tcp_10_close();
C51 COMPILER V9.01   SIM800L                                                               04/03/2019 12:37:18 PAGE 2   

  56          void tcp_11_shut();
  57          
  58          
  59          void main()
  60          {
  61   1              start();
  62   1              while(1);               // 调试用，防止死循环看不出代码差异
  63   1              
  64   1      }
  65          
  66          
  67          void send_byte(unsigned char ch)
  68          {
  69   1              while(TI!=1);
  70   1              TI = 0;
  71   1              SBUF = ch;
  72   1      }
  73          
  74          void send_string(unsigned char *p)
  75          {
  76   1              while(*p != '\0')
  77   1              {
  78   2                      send_byte(*p++);
  79   2              }
  80   1      }
  81          
  82          
  83          
  84          void print_r_datas()
  85          {
  86   1              int i;
  87   1              for(i = 0; i < strlen(r_datas); i++)
  88   1              {
  89   2                      send_byte(r_datas[i]);  
  90   2              }
  91   1      }
  92          
  93          void print_t_datas()
  94          {
  95   1              int i;
  96   1              for(i = 0; i < strlen(t_datas); i++)
  97   1              {
  98   2                      send_byte(t_datas[i]);  
  99   2              }
 100   1      }
 101          
 102          void clean_r_datas()
 103          {
 104   1              memset(r_datas,0,sizeof(r_datas));
 105   1              index = 0;
 106   1      }
 107          
 108          void start()
 109          {
 110   1              UsartConfiguration();
 111   1      
 112   1              P0 = 0x01;       // 0000 0001
 113   1      
 114   1              sim800l_connect();
 115   1      
 116   1              clean_r_datas();
 117   1      
C51 COMPILER V9.01   SIM800L                                                               04/03/2019 12:37:18 PAGE 3   

 118   1              sim800l_set_baud();
 119   1      
 120   1              clean_r_datas();
 121   1      
 122   1              sim800l_set_runmode();
 123   1      
 124   1              clean_r_datas();
 125   1      
 126   1              sim800l_wait_sms();
 127   1      }
 128          
 129          
 130          void sim800l_connect()
 131          {
 132   1              unsigned char *p;
 133   1      
 134   1              while(1)
 135   1              {
 136   2                      send_string(TC_CONNECT);
 137   2      
 138   2                      send_byte(0x0d);
 139   2                      send_byte(0x0a);
 140   2                      Delay1ms(2);
 141   2      
 142   2                      p = strstr(r_datas,"OK");
 143   2                      if(p != NULL)
 144   2                      {
 145   3                              break;
 146   3                      }
 147   2              }
 148   1      }
 149          
 150          void sim800l_set_baud()
 151          {
 152   1              unsigned char *p;
 153   1      
 154   1              while(1)
 155   1              {
 156   2                      send_string(TC_BAUD);
 157   2      
 158   2                      send_byte(0x0d);
 159   2                      send_byte(0x0a);
 160   2                      Delay1ms(2);
 161   2      
 162   2                      p = strstr(r_datas,"OK");
 163   2                      if(p != NULL)
 164   2                      {
 165   3                              break;
 166   3                      }
 167   2              }
 168   1      }
 169          
 170          void sim800l_set_runmode()
 171          {
 172   1              unsigned char *p;
 173   1      
 174   1              while(1)
 175   1              {
 176   2                      send_string(TC_RUNMODE);
 177   2      
 178   2                      send_byte(0x0d);
 179   2                      send_byte(0x0a);
C51 COMPILER V9.01   SIM800L                                                               04/03/2019 12:37:18 PAGE 4   

 180   2                      Delay1ms(2);
 181   2      
 182   2                      p = strstr(r_datas,"OK");
 183   2                      if(p != NULL)
 184   2                      {
 185   3                              break;
 186   3                      }
 187   2              }
 188   1      }
 189          
 190          
 191          void sim800l_wait_sms()
 192          {
 193   1              char *p;
 194   1              while(1)
 195   1              {
 196   2                      // do sms;
 197   2                      P0 = 0x02;       // 0000 0010
 198   2      
 199   2                      send_byte(0x57);                // W
 200   2                      send_byte(0x41);                // A
 201   2                      send_byte(0x49);                // I
 202   2                      send_byte(0x54);                // T
 203   2                      send_byte(0x0d);
 204   2                      send_byte(0x0a);
 205   2                      Delay1ms(20);
 206   2                      
 207   2                      // 这个延迟时间必须足够，不然串口收到的数据（短信）不完整
 208   2                      // 给串口中断足够的时间去接收数据放入数组
 209   2                      p = strstr(r_datas,"CMT");
 210   2                      if(p != NULL)
 211   2                      {
 212   3                              P0 = 0xa5;       // 1010 0101
 213   3      //                      send_byte(0x53);   // S
 214   3      //                      print_r_datas();
 215   3      //                      send_byte(0x53);
 216   3      
 217   3                              // 将收到的数据缓存
 218   3                              strcpy(t_datas,r_datas);
 219   3      
 220   3                              // 清空接收缓存数组
 221   3                              clean_r_datas();
 222   3      
 223   3                              // 短信发送到TCP服务器
 224   3                              tcp();
 225   3      
 226   3                              P0 = 0x0f;       // 0000 1111
 227   3      
 228   3      
 229   3                      }
 230   2                      clean_r_datas();
 231   2              }
 232   1      
 233   1      }
 234          
 235          void tcp()
 236          {
 237   1      
 238   1              send_byte(0x3e);        // '>'
 239   1              send_byte(MAX+'0');
 240   1              send_byte(0x3c);        // '<'
 241   1              
C51 COMPILER V9.01   SIM800L                                                               04/03/2019 12:37:18 PAGE 5   

 242   1              tcp_10_close();
 243   1              Delay1ms(5);
 244   1      
 245   1              tcp_1_checksim();
 246   1              clean_r_datas();
 247   1      
 248   1              tcp_2_checknet();
 249   1              clean_r_datas();
 250   1              tcp_3_checkreg();
 251   1              clean_r_datas();
 252   1      
 253   1              tcp_4_checkgprs();
 254   1              clean_r_datas();
 255   1      
 256   1              tcp_5_setapn();
 257   1              clean_r_datas();
 258   1      
 259   1              tcp_6_getlink();
 260   1              clean_r_datas();
 261   1      
 262   1              tcp_7_getip();
 263   1              clean_r_datas();
 264   1      
 265   1              tcp_8_toserver();
 266   1      //      clean_r_datas();   // 返回的是CONNETC OK，对下一步判断没有影响，可以不用清空，提高运行速度
 267   1      
 268   1              tcp_9_sendtext();
 269   1      //      clean_r_datas();        // 后面无判断，注释掉提高运行速度
 270   1      
 271   1              tcp_10_close();
 272   1      //      clean_r_datas();        // 后面无判断，注释掉提高运行速度
 273   1      
 274   1              tcp_11_shut();
 275   1              clean_r_datas();
 276   1      
 277   1      }
 278          
 279          void tcp_1_checksim()
 280          {
 281   1              unsigned char *p;
 282   1      
 283   1              while(1)
 284   1              {
 285   2                      send_string(TC_TCP_CHECKSIM);
 286   2      
 287   2                      send_byte(0x0d);
 288   2                      send_byte(0x0a);
 289   2                      Delay1ms(20);
 290   2      
 291   2                      //正确返回：
 292   2                      //+CPIN: READY
 293   2      
 294   2                      //OK
 295   2                      p = strstr(r_datas,"OK");
 296   2                      if(p != NULL)
 297   2                      {
 298   3                              P0 = 0x04;       // 0000 0100
 299   3                              break;
 300   3                      }
 301   2              }
 302   1      }
 303          
C51 COMPILER V9.01   SIM800L                                                               04/03/2019 12:37:18 PAGE 6   

 304          void tcp_2_checknet()
 305          {
 306   1              unsigned char *p;
 307   1      
 308   1              while(1)
 309   1              {
 310   2                      send_string(TC_TCP_CHECKNET);
 311   2      
 312   2                      send_byte(0x0d);
 313   2                      send_byte(0x0a);
 314   2                      Delay1ms(20);
 315   2      
 316   2                      //正确返回：
 317   2                      //+CSQ: 20,0
 318   2      
 319   2                      //OK
 320   2                      p = strstr(r_datas,"OK");
 321   2                      if(p != NULL)
 322   2                      {
 323   3                              P0 = 0x08;       // 0000 1000
 324   3                              break;
 325   3                      }
 326   2              }
 327   1      }
 328          
 329          void tcp_3_checkreg()
 330          {
 331   1              unsigned char *p;
 332   1      
 333   1              while(1)
 334   1              {
 335   2                      send_string(TC_TCP_CHECKREG);
 336   2      
 337   2                      send_byte(0x0d);
 338   2                      send_byte(0x0a);
 339   2                      Delay1ms(20);
 340   2      
 341   2                      //正确返回：
 342   2                      //+CREG: 0,1
 343   2      
 344   2                      //OK
 345   2                      p = strstr(r_datas,"OK");
 346   2                      if(p != NULL)
 347   2                      {
 348   3                              P0 = 0x10;       // 0001 0000
 349   3                              break;
 350   3                      }
 351   2              }
 352   1      }
 353          
 354          void tcp_4_checkgprs()
 355          {
 356   1              unsigned char *p;
 357   1      
 358   1              while(1)
 359   1              {
 360   2                      send_string(TC_TCP_CHECKGPRS);
 361   2      
 362   2                      send_byte(0x0d);
 363   2                      send_byte(0x0a);
 364   2                      Delay1ms(20);
 365   2      
C51 COMPILER V9.01   SIM800L                                                               04/03/2019 12:37:18 PAGE 7   

 366   2                      //正确返回：
 367   2                      //+CGATT: 1
 368   2      
 369   2                      //OK
 370   2                      p = strstr(r_datas,"OK");
 371   2                      if(p != NULL)
 372   2                      {
 373   3                              P0 = 0x20;       // 0010 0000
 374   3                              break;
 375   3                      }
 376   2              }
 377   1      }
 378          
 379          void tcp_5_setapn()
 380          {
 381   1      //      unsigned char *p;
 382   1      
 383   1      //      while(1)   // 设置超过一次就会错误
 384   1      //      {
 385   1                      send_string(TC_TCP_SETAPN);
 386   1      
 387   1                      send_byte(0x0d);
 388   1                      send_byte(0x0a);
 389   1                      Delay1ms(20);
 390   1      
 391   1                      P0 = 0x40;       // 0100 0000
 392   1      
 393   1      
 394   1                      //正确返回
 395   1                      //OK
 396   1      //              p = strstr(r_datas,"OK");
 397   1      //              if(p != NULL)
 398   1      //              {
 399   1      //                      break;
 400   1      //              }
 401   1      //      }
 402   1      }
 403          
 404          void tcp_6_getlink()
 405          {
 406   1      //      unsigned char *p;
 407   1      
 408   1      //      while(1)  // 设置超过一次就会错误
 409   1      //      {
 410   1                      send_string(TC_TCP_GETLINK);
 411   1      
 412   1                      send_byte(0x0d);
 413   1                      send_byte(0x0a);
 414   1                      Delay1ms(20);
 415   1      
 416   1                      P0 = 0x80;       // 1000 0000
 417   1      
 418   1      
 419   1                      //正确返回
 420   1                      //OK
 421   1      //              p = strstr(r_datas,"OK");
 422   1      //              if(p != NULL)
 423   1      //              {
 424   1      //                      break;
 425   1      //              }
 426   1      //      }
 427   1      }
C51 COMPILER V9.01   SIM800L                                                               04/03/2019 12:37:18 PAGE 8   

 428          
 429          void tcp_7_getip()
 430          {
 431   1      //      unsigned char *p;
 432   1      
 433   1      //      while(1)  
 434   1      //      {
 435   1                      send_string(TC_TCP_GETIP);
 436   1      
 437   1                      send_byte(0x0d);
 438   1                      send_byte(0x0a);
 439   1                      Delay1ms(20);
 440   1      
 441   1                      P0 = 0x03;       // 0000 0011
 442   1      
 443   1                      //正确返回：
 444   1                      //10.42.6.249
 445   1      //              p = strstr(r_datas,".");
 446   1      //              if(p != NULL)
 447   1      //              {
 448   1      //                      break;
 449   1      //              }
 450   1      //      }
 451   1      }
 452          
 453          void tcp_8_toserver()
 454          {
 455   1              unsigned char *p;
 456   1      
 457   1              while(1)
 458   1              {
 459   2                      send_string(TC_TCP_TOSERVER);
 460   2      
 461   2                      send_byte(0x0d);
 462   2                      send_byte(0x0a);
 463   2                      Delay1ms(100);
 464   2      
 465   2                      P0 = 0x0c;       // 0000 1100
 466   2      
 467   2      //              send_byte(0x30); // 0
 468   2      //              send_byte(0x0d);
 469   2      //              send_byte(0x0a);
 470   2      //              print_r_datas();
 471   2      //              send_byte(0x0d);
 472   2      //              send_byte(0x0a);
 473   2      //              send_byte(0x30); // 0
 474   2      
 475   2      
 476   2                      //正确返回：
 477   2                      //OK
 478   2      
 479   2                      //CONNECT OK
 480   2                      p = strstr(r_datas,"CONNECT OK");
 481   2                      if(p != NULL)
 482   2                      {
 483   3                              break;
 484   3                      }
 485   2              }
 486   1      }
 487          
 488          void tcp_9_sendtext()
 489          {
C51 COMPILER V9.01   SIM800L                                                               04/03/2019 12:37:18 PAGE 9   

 490   1              unsigned char *p;
 491   1              unsigned char *g;
 492   1              int j;
 493   1      
 494   1              while(1)
 495   1              {
 496   2                      send_string(TC_TCP_SENDTEXT);
 497   2      
 498   2                      send_byte(0x0d);
 499   2                      send_byte(0x0a);
 500   2                      Delay1ms(20); // 在调试的时候需要把延迟加大，服务器向串口发送'>'字符串，才会向TCP服务器发送数据
 501   2                                                      // 连接模块的时候可以适当调小
 502   2                      P0 = 0x30;       // 0011 0000
 503   2      
 504   2                      p = strstr(r_datas,">");
 505   2                      if(p != NULL)
 506   2                      {
 507   3                              break;                                                    
 508   3                      }
 509   2              }
 510   1      
 511   1              while(1)
 512   1              {
 513   2                      for(j = 14;j < strlen(t_datas); j++)     // 16 跳过短信前面的无效字符从长度开始发
 514   2                      {
 515   3                              send_byte(t_datas[j]);
 516   3                      }
 517   2      
 518   2                      send_byte(0x0d);
 519   2                      send_byte(0x0a);
 520   2                      send_byte(0x1a);        
 521   2      
 522   2      //              Delay10ms(10);          // 这里不能延迟。延迟会导致收不到SEND OK信号，原因不明  
 523   2                                                               // 无论延迟与否，数据都会发两次才会收到SEND OK信号
 524   2                      send_byte(0x3c);        // '<''
 525   2                      
 526   2                      P0 = 0xc0;       // 1100 0000
 527   2      
 528   2                      g = strstr(r_datas,"SEND OK");
 529   2                      if(g != NULL)
 530   2                      {
 531   3                              P0 = 0xe0;       // 1110 0000
 532   3                              // 清空t_datas
 533   3                              memset(t_datas,0,sizeof(t_datas));
 534   3                              break;
 535   3                      }
 536   2              }
 537   1      }
 538          
 539          void tcp_10_close()
 540          {
 541   1              unsigned char *p;
 542   1      
 543   1      //      while(1)
 544   1      //      {
 545   1                      send_string(TC_TCP_CLOSE);
 546   1      
 547   1                      send_byte(0x0d);
 548   1                      send_byte(0x0a);
 549   1                      Delay1ms(2);
 550   1      
 551   1                      P0 = 0x07;       // 0000 0111
C51 COMPILER V9.01   SIM800L                                                               04/03/2019 12:37:18 PAGE 10  

 552   1      
 553   1                      // 发送成功返回的是字符串 "CLOSE OK"
 554   1                      p = strstr(r_datas,"OK");
 555   1                      if(p != NULL)
 556   1                      {
 557   2      //                      break;
 558   2                      }
 559   1      //      }
 560   1      }
 561          
 562          void tcp_11_shut()
 563          {
 564   1              unsigned char *p;
 565   1              
 566   1              send_string(TC_TCP_SHUT);
 567   1      
 568   1              send_byte(0x0d);
 569   1              send_byte(0x0a);        
 570   1      
 571   1              p = strstr(r_datas,"SHUT OK");
 572   1      
 573   1              P0 = 0x38;       // 0011 1000
 574   1      }
 575          
 576          
 577          
 578          
 579          void serial() interrupt 4
 580          {
 581   1              if(RI == 1)
 582   1              {
 583   2                      RI = 0;
 584   2                      r_datas[index++] = SBUF;
 585   2                      if(index > MAX)
 586   2                      {
 587   3                              MAX = index;
 588   3                      }
 589   2                      if(index > sizeof(r_datas))
 590   2                      {
 591   3                              index = 0;
 592   3                      }
 593   2              }
 594   1      }
 595          
 596          
 597          
 598          void UsartConfiguration()
 599          {
 600   1              SCON=0X52;                      //设置为工作方式1
 601   1              TMOD=0X20;                      //设置计数器工作方式2
 602   1              PCON=0X80;
 603   1              TH1=0XFD;                   //计数器初始值设置，波特率设置为19200
 604   1              TL1=0XFD;                       //晶振从12MHz更换为11.0592MHz
 605   1              ES=1;                                           //打开接收中断
 606   1              EA=1;                                           //打开总中断
 607   1              TR1=1;                                      //打开计数器
 608   1      }
 609          
 610          
 611          void Delay10ms(unsigned int c)   //误差 0us
 612          {
 613   1          unsigned char a, b;
C51 COMPILER V9.01   SIM800L                                                               04/03/2019 12:37:18 PAGE 11  

 614   1      
 615   1              //--c已经在传递过来的时候已经赋值了，所以在for语句第一句就不用赋值了--//
 616   1          for (;c>0;c--)
 617   1              {
 618   2                      for (b=38;b>0;b--)
 619   2                      {
 620   3                              for (a=130;a>0;a--);
 621   3                      }          
 622   2              }       
 623   1      }
 624          
 625          void Delay1ms(unsigned int i)
 626          {
 627   1              unsigned int j;
 628   1              while(i--)
 629   1              {
 630   2                      for(j = 0; j < 125; j++);
 631   2              }
 632   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1247    ----
   CONSTANT SIZE    =    214    ----
   XDATA SIZE       =    800    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      48
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
